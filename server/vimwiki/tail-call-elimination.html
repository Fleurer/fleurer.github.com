<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"> 
<html xmlns="http://www.w3.org/1999/xhtml"> 
<head> 
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
    <style>
        @import url(css/style.css);
    </style>
    <title>tail-call-elimination - fleurer</title>
</head>
<body>
    <div id="main">
        <span id="nav">
            <a href="index.html">&lt;Home</a>
        </span>

<h1 id="toc_1">尾递归优化</h1>

<ul>
<li>
Without tail call optimization each recursive method call creates a new stack frame thereby growing the execution stack.
</li>
<li>
Tail call optimization prevent the stack from growing by replacing the callers frame by the called method's frame.
</li>
<li>
but this optimization can only be done if the infomation in the calling frame is no longer needed.
</li>
</ul>

<h2 id="toc_1.1">hotspot</h2>

<ul>
<li>
the Hotspot VM features mixed execution stacks. 
</li>
<ul>
<li>
An interpreted method's frame might be followed by a compiled method's frame and vice vesa.
</li>
</ul>
<li>
Recognition
</li>
<ul>
<li>
For Java bytecode the recognition of tail calls is also quite simple. A call is a tail call if the method call instruction (invokestatic, invokevirtual, invokeinterface) is immediately followed by one of the return instructions (ireturn, etc) and the method containing the tail call is not synchronized. There must be no exception handler installed for the call instruction.  //只要java字节码中调用方法的指令跟在返回指令之后，就是了。
</li>
</ul>
</ul>
        </div>
    </body>
</html>
