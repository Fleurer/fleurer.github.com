<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>puma quick note</title>
    <link href="css/style.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <textarea id="source">

name: inverse
layout: true
class: center, middle, inverse
---

# puma quick notes

[fleuria](http://fleurer-lee.com)

me.ssword@gmail.com

Melotic Inc.

---
layout: false

## We love puma because it's memory efficient, and modern.

- a good multi-threaded code base

- "Real parallism" (jruby & rubinius only)

- multi-processes support

- hot-deploy / phased restart

---

## But sometimes we just take shit ( aka.*"掉坑"* )

- when we met problem, we goolge for stackoverflow

- then copy & paste their configuration snippets

.footnote[ most time, we just copy solutions but don't take care of *why* ]

---

## For example, we got an Redis::InheritedError

after some googling, we found a reasonable stackoverflow post:

http://stackoverflow.com/questions/18720693/reconnect-with-redis-after-puma-fork

we add these snippet to our puma.rb:

```
on_restart do
  $redis.reconnect
  Rails.cache.reconnect if Rails.cache.respond_to? :reconnect
  ActiveSupport.on_load(:active_record) do
    ActiveRecord::Base.establish_connection
  end
end

on_worker_boot do
  $redis.reconnect
  Rails.cache.reconnect if Rails.cache.respond_to? :reconnect
  ActiveSupport.on_load(:active_record) do
    ActiveRecord::Base.establish_connection
  end
end
```

then the problem seems disappeared, happily ever after.

---

## But it's actually not the fundamental problem of puma

the root cause is *preload_app*

- like Unicorn, puma can preload the rack App to its master process, then just fork workers, without the repeated initializations in each process, *fast*.

- it take advantages of COW *(Copy-on-Write)*, load once, one in-memory code base.

- also, we have COW friendly Garbage Collector, which helps us save memory.

Promising, but...

![](img/puma-preload.png)

---

## The problem of preload_app

- you have to reconnect all your connections

  - how can we ensure *all* connections is reconnected?

- can not take advantage of **phased restart**

---

## Modes

- **Single Mode**

  - single process, multi-threaded

  - *hot restart*: restart after killed all threads, keep connections live but block

- **Clustered Mode**

  - multi processes, multi-threaded

  - *hot restart*: restart after killed all processes

  - *phased restart*: kills processes one by one, do not block connection, but two versions co-exists, we have to take care of keeping schema compatible between deploys.

.footnote[ however, we have to keep schema compatible between deploys in most cases ]

---
name: inverse
layout: true
class: center, middle, inverse
---

# We are hiring!

please contact [subdragon@gmail.com](subdragon@gmail.com)

    </textarea>
    <script src="http://gnab.github.com/remark/downloads/remark-0.5.7.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
          highlightStyle: 'monokai',
          highlightLanguage: 'remark'
        }) ;
    </script>
  </body>
</html>
