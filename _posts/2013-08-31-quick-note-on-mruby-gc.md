---
layout: post
title: "Quick note on mruby GC"
---

前段时间看了一遍 mruby GC，基本把逻辑理清楚了，发补丁补了一些注释之余这里简单记一下。

## 三色 GC

搞过 rails 的同学会有印象，传统 Mark-Sweep 的主要问题是收集时间的不可控 [1]，不幸赶上 GC 的话，页面延迟会比较大。mruby 像 lua 一样将目标设定为可嵌入的解释器，对此很自然的考虑是令 GC 分阶段渐进执行，而三色 GC 也是最正确、最简单的一个渐进式的实现方式。

三色 GC 的思路来自 Knuth 的三色图遍历算法 [2]，对象分为黑、灰、白三种颜色，分别维护在不同的队列里。一轮 GC 的流程很简单：

1. 在一开始，所有对象都是白色，从根对象开始遍历，标记为灰色
2. 随后只要灰色队列中还存在对象，便从中取一个对象，将它标记为黑色，并将它直接引用的对象标记为灰色，然后就允许暂停了 (当然继续跑下去也不碍事，GC 的暂停与否，一般看某些阙值的设定)
3. 待所有灰色对象消失之后，白色对象就是可回收的死对象了。为了让 Sweep 阶段渐进化，可以引入另一种白色，到下一轮 GC 中，新申请的对象换用这种新的白色，至于旧的白色对象就什么时候收集都没关系了。

此外一条铁律是：黑色对象不可以引用白色对象。然而在一轮 GC 期间对象的引用关系难免变化，对此，需要用户手工调用 Write Barrier 同步 [3]。

其间的每一小步遍历的步子迈的都非常小，所以理论上对于延迟敏感的应用，三色 GC 要友好的多。但是因为将 GC 分派到多次执行的同时，也延长了一轮 GC 的周期，期间积累的内存占用会相对多一些。

## 分代 GC

除去三色 GC 将一轮 GC 分派到多次执行以外，另一条渐进式 GC 的思路是缩小每一轮 GC 的范围。好处是两方面的：减少了一轮 GC 的时间，更加及时地回收了内存。分代 GC 也正是最经实战考验的 GC 实现。

mruby 和 lua 都提供了一个分代模式的开关。不同在于 lua 将分代模式视为一个试验 feature，因为它没有性能数据支撑却引入了额外的复杂性而受到质疑，可能会被删除 [4]； 而 mruby 将分代模式默认开启，作为未来主要投入精力的方向，并且将分代模式的 major GC 按三色的方式分成了渐进的几步进行。

然而 mruby 及 lua 的分代 GC 模式并非 "严肃" 的分代实现，而是重用了三色 GC 的基础设施，没有加多少代码就提供了分代的支持，这也正是有趣的地方。在一轮 GC 之后仍存活的黑色对象即被视作老对象，在 Sweep 阶段不予回收，也就是说，象征性地分了两代对象。

## Details on Code

tbd

## Footnotes

- [1]: 或者可控的粒度太粗
- [2]: 题外话，之前无意搜过一次 Map-Reduce 下遍历图的方法，发现正是三色图遍历算法，Map-Reduce 无副作用的的环境下不得不分成多次才能遍历一个图
- [3]: cruby 作为最传统的 Mark-Sweep GC 实现，用户无需手工调用 Write Barrier 的幸福时代已经过时了。在为 mruby 编写扩展时，要分外注意调用 Write Barrier，不然可能会有 seg fault 出现。
- [4]: https://love2d.org/forums/viewtopic.php?f=3&t=10887

## References

- http://wiki.luajit.org/New-Garbage-Collector
