--- 
layout: post
title: "\xE9\x9A\x8F\xE8\xAE\xB0"
tags: 
- "\xE7\xAC\x94\xE8\xAE\xB0"
status: publish
type: post
published: true
meta: 
  _edit_last: "2"
---
<strong>无论何时，只要单个资源需要在多个用户间共享，就必须处理一致性的问题。</strong>
回头想下“函数式语言无副作用适合写并发程序”之类的说法，只是在计算上的并发，对存储上的并发照样得上锁上钥匙。

<strong>win32的窗体使用handle而不是指针</strong>
一个窗体可能会被多个进程处理，也可以隐藏窗体对象的内部实现。

<strong>真空管和三极管的共性</strong>
都可以将信号放大，这一来就可以用电信号来控制开关了。就有了逻辑电路...

<strong>lua从堆栈机转到寄存器机</strong>
因为lua实现里表示值的那个结构体Tvalue是个tagged union，个头太大了(两个指针这么长)。在堆栈上push/pop一来一回吃资源，搞成寄存器机可以省些搬运。

<strong>为什么要有链接器</strong>
可以把程序分成模块。

<strong>C中结构体不可比较</strong>
因为结构体里数据对齐的空隙里面的东西可能随机的。

<strong>C++为什么不用printf</strong>
类型不安全。像cout好像是对每个内置类型都重载了一个<<操作符

<strong>x86实模式的逻辑地址</strong>
x86实模式的逻辑地址是段寄存器（如cs）里存一个基地址(16位)，左移四位再加上一个16位的偏移。
为什么要这么蛋疼，因为当时的主线有20位（可寻址1mb），但是intel的寄存器只有16位。

<strong>自动机</strong>
就是根据输入自动切换状态的计算模型。不过状态有限，识别的语言(语言就是字符串的集合)是最少的。自动机可以识别的语言就叫正则语言。
给自动机加一个堆栈就是下推自动机，这样状态就可以无限了，可以识别的语言就叫上下文无关语言。
给自动机加一个随机存储，就是图灵机了。可以识别的语言就叫图灵可识别语言，但是识别的时候不一定能停机。只要能停机，不管识别正确还是识别错误，这门语言就是可判定语言。
