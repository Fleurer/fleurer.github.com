--- 
layout: post
title: "\xE5\x90\x84\xE7\xA7\x8D\xE5\x9E\x83\xE5\x9C\xBE\xE6\x94\xB6\xE9\x9B\x86\xE7\x9A\x84\xE9\x9A\x8F\xE4\xBE\xBF\xE7\xAC\x94\xE8\xAE\xB0"
tags: 
- GC
- VM
- "\xE7\xAC\x94\xE8\xAE\xB0"
status: publish
type: post
published: true
meta: 
  _edit_last: "2"
---
GC多好多好就不多说了。没银弹嘛，什么好处什么坏处都了解下就好 TvT

<h3>引用计数</h3>

“穷人的垃圾收集”。实现简单，可以在对象失去引用时立即收集，不过对付不了循环引用。“立即收集”容易给人一种“高效”的印象，其实正相反，引用计数中的每个mov指令后面都必须跟着几条额外指令，引用的局部性还不好。跟各种GC算法比起来，引用计数的效率是最低的 :(

CPython是引用计数加备用的mark-sweep，（好像如果一开始就使用GC的话就没必要引入那套复杂的内存池机制了？

<h3>mark-sweep</h3>

从根（寄存器、局部变量和全局变量等）开始，遍历所有可访问的对象并标记之;再遍历所有变量，将所有没mark的对象收集。

C\C++中的GC实现大约是扫描bss段和堆栈什么的，找到全局变量和局部变量。C\C++中你不知道一块数据是指针还是一个纯洁的整数，所以只能用个is point to heap来猜它是不是指针，如果这个整数恰好是一块内存的地址，就只能“保守地”当它是指针mark掉。要这个“保守地”被mark掉的地址恰好是一堆对象的根就杯具了。保守式的GC中比较有名的就是Boehm的GC，很靠谱，可以通过统计回避刚说的那个杯具。

<h3>停止-复制</h3>

这个需要额外一倍的内存空间。先将一切活动停止，遍历堆中所有可以访问的对象并将其拷贝到另个堆中，并将将原先的指针统统指向新的堆中对应的地址，完毕后继续程序的执行。

停止复制的同时也紧缩了内存，因而不存在内存碎片的问题（malloc/free在整理堆中碎片时候的各种搬运不容小觑），性能上好像要优于mark-sweep。缺点就是对空间浪费比较大（一倍啊一倍~）。

<h3>分代收集</h3>

遍历所有对象时候的停滞会比较厉害。想办法把停滞缩短到人类察觉不到吧...就有了分代收集和增量收集。

分代收集基于这样的假设: 

1.对象越新，生存期越短;
2.对象越老，生存期越长;
3.少有指向新对象的老对象

就把堆分成n块，对应n代的对象（三代就差不多吧）。再加个记忆表什么的记下指向新对象的老对象，以记忆表中的老对象以及活跃的变量等做根，重点照顾最新的这代就行了。

.net那CLR好像是分代的...缺点是经过多次收集，较老的代会积攒比较多的垃圾。

<h3>增量收集</h3>

增量收集好像是记住上次遍历到了什么地方，然后每次遍历一点，最后集中收集。

有个三色标记：
  白色：未被访问的对象;
  灰色：已经被访问过，子对象还未访问;
  黑色：已经被访问过，子对象也已被访问;

然后就是性质：
  当没有灰色对象时，所有的白色对象都是垃圾;
  不会有黑色对象指向白色对象;
  每个灰色对象都位于收集器的队列中（作为下次收集的根）;
